<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI Integration Tests</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-suite {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        .test-case {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }
        .test-result {
            padding: 8px 12px;
            margin: 5px 0;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        .pass { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .fail { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .summary {
            background: #e9ecef;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        .error-details {
            background: #fff3cd;
            color: #856404;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border: 1px solid #ffeaa7;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .test-dom {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .timeline-item {
            background: white;
            border: 1px solid #dee2e6;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .statistics-display {
            background: #e9ecef;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 500px;
        }
        .modal.show {
            display: block;
        }
    </style>
</head>
<body>
    <h1>UI Integration Tests</h1>
    <p>Integration tests for timeline rendering, modal integration, and statistics display updates.</p>
    
    <div class="summary" id="test-summary">
        <div>Total Tests: <span id="total-tests">0</span></div>
        <div>Passed: <span id="passed-tests">0</span></div>
        <div>Failed: <span id="failed-tests">0</span></div>
        <div>Success Rate: <span id="success-rate">0%</span></div>
    </div>

    <button onclick="runAllTests()">Run All Tests</button>
    <button onclick="clearResults()">Clear Results</button>
    <button onclick="runTimelineTests()">Run Timeline Tests Only</button>
    <button onclick="runModalTests()">Run Modal Tests Only</button>
    <button onclick="runStatisticsTests()">Run Statistics Tests Only</button>

    <!-- Test DOM Elements -->
    <div class="test-dom" id="test-dom">
        <h3>Test DOM Elements</h3>
        
        <!-- Timeline Container -->
        <div id="match-log-container">
            <h4>Timeline</h4>
            <div id="match-log"></div>
        </div>
        
        <!-- Statistics Display -->
        <div id="statistics-container">
            <h4>Statistics</h4>
            <div class="statistics-display">
                <span>Goals: <span id="goals-count">0</span></span>
                <span>Cards: <span id="cards-count">0</span></span>
                <span>Fouls: <span id="fouls-count">0</span></span>
                <span>Total: <span id="total-events-count">0</span></span>
            </div>
        </div>
        
        <!-- Team Elements -->
        <div id="team-elements">
            <div id="Team1NameElement">Team A</div>
            <div id="Team2NameElement">Team B</div>
            <div id="firstScoreElement">2</div>
            <div id="secondScoreElement">1</div>
        </div>
    </div>

    <!-- Test Modals -->
    <div class="modal" id="recordEventModal">
        <div class="modal-content">
            <h3>Record Event Modal</h3>
            <form id="recordEventForm">
                <select id="eventTypeSelect">
                    <option value="">Choose event type...</option>
                    <option value="Goal">Goal</option>
                    <option value="Yellow Card">Yellow Card</option>
                    <option value="Red Card">Red Card</option>
                    <option value="Foul">Foul</option>
                </select>
                <textarea id="eventNotes" placeholder="Notes..."></textarea>
                <button type="submit">Record Event</button>
                <button type="button" onclick="hideModal('recordEventModal')">Cancel</button>
            </form>
        </div>
    </div>

    <div class="modal" id="editEventModal">
        <div class="modal-content">
            <h3>Edit Event Modal</h3>
            <form id="editEventForm">
                <input type="hidden" id="editEventIndex">
                <input type="number" id="editEventTime" placeholder="Time in minutes">
                <select id="editEventType">
                    <option value="Goal">Goal</option>
                    <option value="Yellow Card">Yellow Card</option>
                    <option value="Red Card">Red Card</option>
                </select>
                <textarea id="editEventNotes" placeholder="Notes..."></textarea>
                <button type="submit">Update Event</button>
                <button type="button" onclick="hideModal('editEventModal')">Cancel</button>
            </form>
        </div>
    </div>

    <div id="test-results"></div>

    <script type="module">
        // Simple test framework
        class TestFramework {
            constructor() {
                this.tests = [];
                this.results = [];
                this.currentSuite = null;
            }

            describe(suiteName, testFunction) {
                this.currentSuite = suiteName;
                const suiteDiv = document.createElement('div');
                suiteDiv.className = 'test-suite';
                suiteDiv.innerHTML = `<h2>${suiteName}</h2>`;
                document.getElementById('test-results').appendChild(suiteDiv);
                
                testFunction();
                this.currentSuite = null;
            }

            it(testName, testFunction) {
                const testCase = {
                    suite: this.currentSuite,
                    name: testName,
                    function: testFunction
                };
                this.tests.push(testCase);
            }

            async runTests() {
                this.results = [];
                let passed = 0;
                let failed = 0;

                for (const test of this.tests) {
                    try {
                        await test.function();
                        this.addResult(test.suite, test.name, true);
                        passed++;
                    } catch (error) {
                        this.addResult(test.suite, test.name, false, error);
                        failed++;
                    }
                }

                this.updateSummary(passed, failed);
                return { passed, failed, total: this.tests.length };
            }

            addResult(suite, testName, passed, error = null) {
                const suiteDiv = Array.from(document.querySelectorAll('.test-suite'))
                    .find(div => div.querySelector('h2').textContent === suite);
                
                if (suiteDiv) {
                    const testDiv = document.createElement('div');
                    testDiv.className = 'test-case';
                    
                    const resultDiv = document.createElement('div');
                    resultDiv.className = `test-result ${passed ? 'pass' : 'fail'}`;
                    resultDiv.textContent = `${passed ? '✓' : '✗'} ${testName}`;
                    
                    testDiv.appendChild(resultDiv);
                    
                    if (!passed && error) {
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'error-details';
                        errorDiv.textContent = `Error: ${error.message}\nStack: ${error.stack}`;
                        testDiv.appendChild(errorDiv);
                    }
                    
                    suiteDiv.appendChild(testDiv);
                }
            }

            updateSummary(passed, failed) {
                const total = passed + failed;
                const successRate = total > 0 ? Math.round((passed / total) * 100) : 0;
                
                document.getElementById('total-tests').textContent = total;
                document.getElementById('passed-tests').textContent = passed;
                document.getElementById('failed-tests').textContent = failed;
                document.getElementById('success-rate').textContent = `${successRate}%`;
            }

            expect(actual) {
                return {
                    toBe: (expected) => {
                        if (actual !== expected) {
                            throw new Error(`Expected ${expected}, but got ${actual}`);
                        }
                    },
                    toEqual: (expected) => {
                        if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                            throw new Error(`Expected ${JSON.stringify(expected)}, but got ${JSON.stringify(actual)}`);
                        }
                    },
                    toBeTruthy: () => {
                        if (!actual) {
                            throw new Error(`Expected truthy value, but got ${actual}`);
                        }
                    },
                    toBeFalsy: () => {
                        if (actual) {
                            throw new Error(`Expected falsy value, but got ${actual}`);
                        }
                    },
                    toContain: (expected) => {
                        if (Array.isArray(actual)) {
                            if (!actual.includes(expected)) {
                                throw new Error(`Expected array to contain ${expected}`);
                            }
                        } else if (typeof actual === 'string') {
                            if (!actual.includes(expected)) {
                                throw new Error(`Expected string to contain "${expected}"`);
                            }
                        } else {
                            throw new Error('toContain can only be used with arrays or strings');
                        }
                    },
                    toHaveProperty: (property) => {
                        if (!(property in actual)) {
                            throw new Error(`Expected object to have property "${property}"`);
                        }
                    },
                    toBeInstanceOf: (constructor) => {
                        if (!(actual instanceof constructor)) {
                            throw new Error(`Expected ${actual} to be instance of ${constructor.name}`);
                        }
                    },
                    toHaveLength: (length) => {
                        if (actual.length !== length) {
                            throw new Error(`Expected length ${length}, but got ${actual.length}`);
                        }
                    }
                };
            }
        }

        // Initialize test framework
        const testFramework = new TestFramework();
        window.describe = testFramework.describe.bind(testFramework);
        window.it = testFramework.it.bind(testFramework);
        window.expect = testFramework.expect.bind(testFramework);

        // Mock dependencies and create test event manager
        const mockGameState = {
            goals: [],
            matchEvents: [],
            team1Score: 0,
            team2Score: 0
        };

        const EVENT_TYPES = {
            GOAL: 'Goal',
            YELLOW_CARD: 'Yellow Card',
            RED_CARD: 'Red Card',
            FOUL: 'Foul',
            INCIDENT: 'Incident',
            PENALTY: 'Penalty',
            SIN_BIN: 'Sin Bin',
            HALF_TIME: 'Half Time',
            FULL_TIME: 'Full Time'
        };

        // Test UI Manager for integration testing
        class TestUIManager {
            constructor() {
                this.gameState = mockGameState;
                this.EVENT_TYPES = EVENT_TYPES;
                this.timelineContainer = document.getElementById('match-log');
                this.statisticsElements = {
                    goals: document.getElementById('goals-count'),
                    cards: document.getElementById('cards-count'),
                    fouls: document.getElementById('fouls-count'),
                    total: document.getElementById('total-events-count')
                };
            }

            // Timeline rendering methods
            renderTimeline() {
                if (!this.timelineContainer) return;

                // Clear existing timeline
                this.timelineContainer.innerHTML = '';

                // Create combined events array
                const allEvents = [
                    ...this.gameState.goals.map(goal => ({ ...goal, updatetype: 'goal' })),
                    ...this.gameState.matchEvents.map(event => ({ ...event, updatetype: 'matchEvent' }))
                ];

                // Sort by raw time
                allEvents.sort((a, b) => (b.rawTime || 0) - (a.rawTime || 0));

                if (allEvents.length === 0) {
                    this.timelineContainer.innerHTML = '<div class="timeline-item">No events recorded yet</div>';
                    return;
                }

                // Use document fragment for efficient DOM updates
                const fragment = document.createDocumentFragment();

                allEvents.forEach((event, index) => {
                    const timelineItem = this.createTimelineItem(event, index);
                    fragment.appendChild(timelineItem);
                });

                this.timelineContainer.appendChild(fragment);
            }

            createTimelineItem(event, index) {
                const item = document.createElement('div');
                item.className = 'timeline-item';
                item.dataset.eventIndex = index;
                item.dataset.eventType = event.updatetype;

                const eventIcon = this.getEventIcon(event.type);
                const eventClass = this.getEventCardClass(event.type);

                if (event.updatetype === 'goal') {
                    item.innerHTML = this.createGoalEventHTML(event, eventIcon, eventClass);
                } else {
                    item.innerHTML = this.createMatchEventHTML(event, eventIcon, eventClass);
                }

                return item;
            }

            createGoalEventHTML(goal, icon, cardClass) {
                return `
                    <div class="event-content ${cardClass}">
                        <div class="event-header">
                            <span class="event-icon">${icon}</span>
                            <span class="event-time">${goal.timestamp || 'Unknown'}</span>
                            <span class="event-type">Goal</span>
                        </div>
                        <div class="event-details">
                            <strong>${goal.goalScorerName || 'Unknown'}</strong>
                            ${goal.goalScorerShirtNumber ? `(#${goal.goalScorerShirtNumber})` : ''}
                            ${goal.goalAssistName ? `<br>Assist: ${goal.goalAssistName}` : ''}
                            ${goal.goalAssistShirtNumber ? `(#${goal.goalAssistShirtNumber})` : ''}
                        </div>
                        <div class="event-actions">
                            <button onclick="editEvent(${goal.originalIndex || 0}, 'goal')">Edit</button>
                            <button onclick="deleteEvent(${goal.originalIndex || 0}, 'goal')">Delete</button>
                        </div>
                    </div>
                `;
            }

            createMatchEventHTML(event, icon, cardClass) {
                return `
                    <div class="event-content ${cardClass}">
                        <div class="event-header">
                            <span class="event-icon">${icon}</span>
                            <span class="event-time">${event.timestamp || 'Unknown'}</span>
                            <span class="event-type">${event.type || 'Unknown'}</span>
                        </div>
                        <div class="event-details">
                            ${event.teamName ? `<strong>${event.teamName}</strong><br>` : ''}
                            ${event.notes || ''}
                        </div>
                        <div class="event-actions">
                            <button onclick="editEvent(${event.originalIndex || 0}, 'matchEvent')">Edit</button>
                            <button onclick="deleteEvent(${event.originalIndex || 0}, 'matchEvent')">Delete</button>
                        </div>
                    </div>
                `;
            }

            getEventIcon(eventType) {
                const icons = {
                    'Goal': '⚽',
                    'Yellow Card': '🟨',
                    'Red Card': '🟥',
                    'Foul': '⚠️',
                    'Penalty': '🎯',
                    'Incident': '❗',
                    'Sin Bin': '⏰'
                };
                return icons[eventType] || '📝';
            }

            getEventCardClass(eventType) {
                const classes = {
                    'Goal': 'goal-event',
                    'Yellow Card': 'warning-event',
                    'Red Card': 'danger-event',
                    'Foul': 'warning-event',
                    'Penalty': 'info-event',
                    'Incident': 'warning-event'
                };
                return classes[eventType] || 'default-event';
            }

            // Statistics calculation and display
            calculateStatistics() {
                const stats = {
                    goals: 0,
                    cards: 0,
                    fouls: 0,
                    total: 0
                };

                // Count valid goals
                stats.goals = this.gameState.goals.filter(goal => !goal.disallowed).length;

                // Count events by type
                this.gameState.matchEvents.forEach(event => {
                    if (event.type === this.EVENT_TYPES.YELLOW_CARD || event.type === this.EVENT_TYPES.RED_CARD) {
                        stats.cards++;
                    }
                    if (event.type === this.EVENT_TYPES.FOUL) {
                        stats.fouls++;
                    }
                });

                stats.total = stats.goals + this.gameState.matchEvents.length;

                return stats;
            }

            updateStatisticsDisplay() {
                const stats = this.calculateStatistics();

                if (this.statisticsElements.goals) {
                    this.statisticsElements.goals.textContent = stats.goals;
                }
                if (this.statisticsElements.cards) {
                    this.statisticsElements.cards.textContent = stats.cards;
                }
                if (this.statisticsElements.fouls) {
                    this.statisticsElements.fouls.textContent = stats.fouls;
                }
                if (this.statisticsElements.total) {
                    this.statisticsElements.total.textContent = stats.total;
                }
            }

            // Modal management
            showRecordEventModal() {
                const modal = document.getElementById('recordEventModal');
                if (modal) {
                    modal.classList.add('show');
                    return true;
                }
                return false;
            }

            showEditEventModal(index, type) {
                const modal = document.getElementById('editEventModal');
                if (modal) {
                    // Populate form with event data
                    const event = type === 'goal' ? this.gameState.goals[index] : this.gameState.matchEvents[index];
                    if (event) {
                        const indexInput = document.getElementById('editEventIndex');
                        const timeInput = document.getElementById('editEventTime');
                        const typeSelect = document.getElementById('editEventType');
                        const notesInput = document.getElementById('editEventNotes');

                        if (indexInput) indexInput.value = index;
                        if (timeInput) timeInput.value = Math.floor((event.rawTime || 0) / 60);
                        if (typeSelect) typeSelect.value = event.type || '';
                        if (notesInput) notesInput.value = event.notes || '';

                        modal.classList.add('show');
                        return true;
                    }
                }
                return false;
            }

            hideModal(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('show');
                    return true;
                }
                return false;
            }

            // Test helper methods
            addTestEvent(eventData) {
                if (eventData.updatetype === 'goal') {
                    this.gameState.goals.push(eventData);
                } else {
                    this.gameState.matchEvents.push(eventData);
                }
            }

            clearTestData() {
                this.gameState.goals = [];
                this.gameState.matchEvents = [];
                this.gameState.team1Score = 0;
                this.gameState.team2Score = 0;
            }

            getTimelineItemCount() {
                return this.timelineContainer ? this.timelineContainer.children.length : 0;
            }

            getTimelineItemByIndex(index) {
                return this.timelineContainer ? this.timelineContainer.children[index] : null;
            }
        }

        // Create test instance
        let uiManager;

        // Global functions for modal testing
        window.showModal = (modalId) => {
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('show');
        };

        window.hideModal = (modalId) => {
            const modal = document.getElementById(modalId);
            if (modal) modal.classList.remove('show');
        };

        window.editEvent = (index, type) => {
            console.log(`Edit event: ${index}, ${type}`);
        };

        window.deleteEvent = (index, type) => {
            console.log(`Delete event: ${index}, ${type}`);
        };

        // Test suites
        describe('Timeline Rendering with Various Event Combinations', () => {
            it('should render empty timeline correctly', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                uiManager.renderTimeline();
                
                expect(uiManager.getTimelineItemCount()).toBe(1);
                const emptyMessage = uiManager.getTimelineItemByIndex(0);
                expect(emptyMessage.textContent).toContain('No events recorded yet');
            });

            it('should render single goal event', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const goalEvent = {
                    updatetype: 'goal',
                    timestamp: '15:30',
                    rawTime: 930,
                    goalScorerName: 'John Doe',
                    goalScorerShirtNumber: '10',
                    type: 'Goal'
                };
                
                uiManager.addTestEvent(goalEvent);
                uiManager.renderTimeline();
                
                expect(uiManager.getTimelineItemCount()).toBe(1);
                const timelineItem = uiManager.getTimelineItemByIndex(0);
                expect(timelineItem.textContent).toContain('John Doe');
                expect(timelineItem.textContent).toContain('15:30');
                expect(timelineItem.textContent).toContain('Goal');
            });

            it('should render single match event', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const matchEvent = {
                    updatetype: 'matchEvent',
                    timestamp: '25:45',
                    rawTime: 1545,
                    type: 'Yellow Card',
                    teamName: 'Team A',
                    notes: 'Unsporting behavior'
                };
                
                uiManager.addTestEvent(matchEvent);
                uiManager.renderTimeline();
                
                expect(uiManager.getTimelineItemCount()).toBe(1);
                const timelineItem = uiManager.getTimelineItemByIndex(0);
                expect(timelineItem.textContent).toContain('Yellow Card');
                expect(timelineItem.textContent).toContain('25:45');
                expect(timelineItem.textContent).toContain('Team A');
                expect(timelineItem.textContent).toContain('Unsporting behavior');
            });

            it('should render multiple events in correct chronological order', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                // Add events in non-chronological order
                const events = [
                    {
                        updatetype: 'goal',
                        timestamp: '30:00',
                        rawTime: 1800,
                        goalScorerName: 'Jane Smith',
                        type: 'Goal'
                    },
                    {
                        updatetype: 'matchEvent',
                        timestamp: '15:30',
                        rawTime: 930,
                        type: 'Yellow Card',
                        teamName: 'Team B'
                    },
                    {
                        updatetype: 'matchEvent',
                        timestamp: '45:00',
                        rawTime: 2700,
                        type: 'Red Card',
                        teamName: 'Team A'
                    }
                ];
                
                events.forEach(event => uiManager.addTestEvent(event));
                uiManager.renderTimeline();
                
                expect(uiManager.getTimelineItemCount()).toBe(3);
                
                // Should be ordered by most recent first (descending rawTime)
                const firstItem = uiManager.getTimelineItemByIndex(0);
                const secondItem = uiManager.getTimelineItemByIndex(1);
                const thirdItem = uiManager.getTimelineItemByIndex(2);
                
                expect(firstItem.textContent).toContain('45:00'); // Red Card
                expect(secondItem.textContent).toContain('30:00'); // Goal
                expect(thirdItem.textContent).toContain('15:30'); // Yellow Card
            });

            it('should render mixed event types with proper icons and classes', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const events = [
                    {
                        updatetype: 'goal',
                        timestamp: '20:00',
                        rawTime: 1200,
                        goalScorerName: 'Player 1',
                        type: 'Goal'
                    },
                    {
                        updatetype: 'matchEvent',
                        timestamp: '25:00',
                        rawTime: 1500,
                        type: 'Yellow Card',
                        teamName: 'Team A'
                    },
                    {
                        updatetype: 'matchEvent',
                        timestamp: '35:00',
                        rawTime: 2100,
                        type: 'Foul',
                        teamName: 'Team B'
                    }
                ];
                
                events.forEach(event => uiManager.addTestEvent(event));
                uiManager.renderTimeline();
                
                expect(uiManager.getTimelineItemCount()).toBe(3);
                
                // Check that different event types have different icons
                const timelineHTML = uiManager.timelineContainer.innerHTML;
                expect(timelineHTML).toContain('⚽'); // Goal icon
                expect(timelineHTML).toContain('🟨'); // Yellow card icon
                expect(timelineHTML).toContain('⚠️'); // Foul icon
            });

            it('should handle events with missing data gracefully', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const incompleteEvent = {
                    updatetype: 'matchEvent',
                    type: 'Incident'
                    // Missing timestamp, rawTime, etc.
                };
                
                uiManager.addTestEvent(incompleteEvent);
                uiManager.renderTimeline();
                
                expect(uiManager.getTimelineItemCount()).toBe(1);
                const timelineItem = uiManager.getTimelineItemByIndex(0);
                expect(timelineItem.textContent).toContain('Incident');
                expect(timelineItem.textContent).toContain('Unknown'); // Should show "Unknown" for missing timestamp
            });
        });

        describe('Modal Integration and Form Handling', () => {
            it('should show record event modal', () => {
                uiManager = new TestUIManager();
                
                const result = uiManager.showRecordEventModal();
                expect(result).toBe(true);
                
                const modal = document.getElementById('recordEventModal');
                expect(modal.classList.contains('show')).toBe(true);
            });

            it('should hide record event modal', () => {
                uiManager = new TestUIManager();
                
                // First show the modal
                uiManager.showRecordEventModal();
                
                // Then hide it
                const result = uiManager.hideModal('recordEventModal');
                expect(result).toBe(true);
                
                const modal = document.getElementById('recordEventModal');
                expect(modal.classList.contains('show')).toBe(false);
            });

            it('should show edit event modal with populated data', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const testEvent = {
                    updatetype: 'matchEvent',
                    timestamp: '30:00',
                    rawTime: 1800,
                    type: 'Yellow Card',
                    notes: 'Test notes'
                };
                
                uiManager.addTestEvent(testEvent);
                
                const result = uiManager.showEditEventModal(0, 'matchEvent');
                expect(result).toBe(true);
                
                const modal = document.getElementById('editEventModal');
                expect(modal.classList.contains('show')).toBe(true);
                
                // Check that form is populated
                const timeInput = document.getElementById('editEventTime');
                const typeSelect = document.getElementById('editEventType');
                const notesInput = document.getElementById('editEventNotes');
                
                expect(timeInput.value).toBe('30'); // 1800 seconds / 60 = 30 minutes
                expect(typeSelect.value).toBe('Yellow Card');
                expect(notesInput.value).toBe('Test notes');
            });

            it('should handle edit modal for goal events', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const testGoal = {
                    updatetype: 'goal',
                    timestamp: '15:30',
                    rawTime: 930,
                    type: 'Goal',
                    goalScorerName: 'Test Player',
                    notes: 'Great goal'
                };
                
                uiManager.addTestEvent(testGoal);
                
                const result = uiManager.showEditEventModal(0, 'goal');
                expect(result).toBe(true);
                
                const modal = document.getElementById('editEventModal');
                expect(modal.classList.contains('show')).toBe(true);
            });

            it('should handle form validation in record modal', () => {
                uiManager = new TestUIManager();
                
                const form = document.getElementById('recordEventForm');
                const eventTypeSelect = document.getElementById('eventTypeSelect');
                const eventNotes = document.getElementById('eventNotes');
                
                // Test form elements exist
                expect(form).toBeTruthy();
                expect(eventTypeSelect).toBeTruthy();
                expect(eventNotes).toBeTruthy();
                
                // Test form can be populated
                eventTypeSelect.value = 'Yellow Card';
                eventNotes.value = 'Test event notes';
                
                expect(eventTypeSelect.value).toBe('Yellow Card');
                expect(eventNotes.value).toBe('Test event notes');
            });

            it('should handle form validation in edit modal', () => {
                uiManager = new TestUIManager();
                
                const form = document.getElementById('editEventForm');
                const editEventTime = document.getElementById('editEventTime');
                const editEventType = document.getElementById('editEventType');
                const editEventNotes = document.getElementById('editEventNotes');
                
                // Test form elements exist
                expect(form).toBeTruthy();
                expect(editEventTime).toBeTruthy();
                expect(editEventType).toBeTruthy();
                expect(editEventNotes).toBeTruthy();
                
                // Test form can be populated
                editEventTime.value = '25';
                editEventType.value = 'Red Card';
                editEventNotes.value = 'Updated notes';
                
                expect(editEventTime.value).toBe('25');
                expect(editEventType.value).toBe('Red Card');
                expect(editEventNotes.value).toBe('Updated notes');
            });

            it('should return false when trying to show non-existent modal', () => {
                uiManager = new TestUIManager();
                
                const result = uiManager.hideModal('nonExistentModal');
                expect(result).toBe(false);
            });
        });

        describe('Statistics Display Updates', () => {
            it('should display zero statistics for empty game state', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const stats = uiManager.calculateStatistics();
                expect(stats.goals).toBe(0);
                expect(stats.cards).toBe(0);
                expect(stats.fouls).toBe(0);
                expect(stats.total).toBe(0);
                
                uiManager.updateStatisticsDisplay();
                
                expect(uiManager.statisticsElements.goals.textContent).toBe('0');
                expect(uiManager.statisticsElements.cards.textContent).toBe('0');
                expect(uiManager.statisticsElements.fouls.textContent).toBe('0');
                expect(uiManager.statisticsElements.total.textContent).toBe('0');
            });

            it('should calculate and display goal statistics correctly', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                // Add valid goals
                const goals = [
                    { goalScorerName: 'Player 1', disallowed: false },
                    { goalScorerName: 'Player 2', disallowed: false },
                    { goalScorerName: 'Player 3', disallowed: true } // This should not count
                ];
                
                goals.forEach(goal => uiManager.gameState.goals.push(goal));
                
                const stats = uiManager.calculateStatistics();
                expect(stats.goals).toBe(2); // Only non-disallowed goals
                
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.goals.textContent).toBe('2');
            });

            it('should calculate and display card statistics correctly', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const events = [
                    { type: 'Yellow Card' },
                    { type: 'Yellow Card' },
                    { type: 'Red Card' },
                    { type: 'Foul' }, // This should not count as a card
                    { type: 'Incident' } // This should not count as a card
                ];
                
                events.forEach(event => uiManager.gameState.matchEvents.push(event));
                
                const stats = uiManager.calculateStatistics();
                expect(stats.cards).toBe(3); // 2 yellow + 1 red
                
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.cards.textContent).toBe('3');
            });

            it('should calculate and display foul statistics correctly', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                const events = [
                    { type: 'Foul' },
                    { type: 'Foul' },
                    { type: 'Yellow Card' }, // This should not count as a foul
                    { type: 'Foul' }
                ];
                
                events.forEach(event => uiManager.gameState.matchEvents.push(event));
                
                const stats = uiManager.calculateStatistics();
                expect(stats.fouls).toBe(3);
                
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.fouls.textContent).toBe('3');
            });

            it('should calculate total events correctly', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                // Add goals
                uiManager.gameState.goals.push({ goalScorerName: 'Player 1' });
                uiManager.gameState.goals.push({ goalScorerName: 'Player 2' });
                
                // Add match events
                uiManager.gameState.matchEvents.push({ type: 'Yellow Card' });
                uiManager.gameState.matchEvents.push({ type: 'Foul' });
                uiManager.gameState.matchEvents.push({ type: 'Incident' });
                
                const stats = uiManager.calculateStatistics();
                expect(stats.total).toBe(5); // 2 goals + 3 match events
                
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.total.textContent).toBe('5');
            });

            it('should handle comprehensive statistics with mixed event types', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                // Add goals (some disallowed)
                uiManager.gameState.goals.push({ goalScorerName: 'Player 1', disallowed: false });
                uiManager.gameState.goals.push({ goalScorerName: 'Player 2', disallowed: true });
                uiManager.gameState.goals.push({ goalScorerName: 'Player 3', disallowed: false });
                
                // Add various match events
                const events = [
                    { type: 'Yellow Card' },
                    { type: 'Yellow Card' },
                    { type: 'Red Card' },
                    { type: 'Foul' },
                    { type: 'Foul' },
                    { type: 'Penalty' },
                    { type: 'Incident' }
                ];
                
                events.forEach(event => uiManager.gameState.matchEvents.push(event));
                
                const stats = uiManager.calculateStatistics();
                
                expect(stats.goals).toBe(2); // 2 non-disallowed goals
                expect(stats.cards).toBe(3); // 2 yellow + 1 red
                expect(stats.fouls).toBe(2); // 2 fouls
                expect(stats.total).toBe(10); // 3 goals + 7 match events
                
                uiManager.updateStatisticsDisplay();
                
                expect(uiManager.statisticsElements.goals.textContent).toBe('2');
                expect(uiManager.statisticsElements.cards.textContent).toBe('3');
                expect(uiManager.statisticsElements.fouls.textContent).toBe('2');
                expect(uiManager.statisticsElements.total.textContent).toBe('10');
            });

            it('should update statistics display when events change', () => {
                uiManager = new TestUIManager();
                uiManager.clearTestData();
                
                // Initial state - no events
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.total.textContent).toBe('0');
                
                // Add an event
                uiManager.gameState.matchEvents.push({ type: 'Yellow Card' });
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.cards.textContent).toBe('1');
                expect(uiManager.statisticsElements.total.textContent).toBe('1');
                
                // Add a goal
                uiManager.gameState.goals.push({ goalScorerName: 'Player 1', disallowed: false });
                uiManager.updateStatisticsDisplay();
                expect(uiManager.statisticsElements.goals.textContent).toBe('1');
                expect(uiManager.statisticsElements.total.textContent).toBe('2');
            });
        });

        // Global test runner functions
        window.runAllTests = async () => {
            document.getElementById('test-results').innerHTML = '';
            await testFramework.runTests();
        };

        window.clearResults = () => {
            document.getElementById('test-results').innerHTML = '';
            document.getElementById('total-tests').textContent = '0';
            document.getElementById('passed-tests').textContent = '0';
            document.getElementById('failed-tests').textContent = '0';
            document.getElementById('success-rate').textContent = '0%';
            testFramework.tests = [];
            testFramework.results = [];
        };

        window.runTimelineTests = async () => {
            document.getElementById('test-results').innerHTML = '';
            const timelineTests = testFramework.tests.filter(test => 
                test.suite === 'Timeline Rendering with Various Event Combinations'
            );
            
            let passed = 0;
            let failed = 0;
            
            for (const test of timelineTests) {
                try {
                    await test.function();
                    testFramework.addResult(test.suite, test.name, true);
                    passed++;
                } catch (error) {
                    testFramework.addResult(test.suite, test.name, false, error);
                    failed++;
                }
            }
            
            testFramework.updateSummary(passed, failed);
        };

        window.runModalTests = async () => {
            document.getElementById('test-results').innerHTML = '';
            const modalTests = testFramework.tests.filter(test => 
                test.suite === 'Modal Integration and Form Handling'
            );
            
            let passed = 0;
            let failed = 0;
            
            for (const test of modalTests) {
                try {
                    await test.function();
                    testFramework.addResult(test.suite, test.name, true);
                    passed++;
                } catch (error) {
                    testFramework.addResult(test.suite, test.name, false, error);
                    failed++;
                }
            }
            
            testFramework.updateSummary(passed, failed);
        };

        window.runStatisticsTests = async () => {
            document.getElementById('test-results').innerHTML = '';
            const statisticsTests = testFramework.tests.filter(test => 
                test.suite === 'Statistics Display Updates'
            );
            
            let passed = 0;
            let failed = 0;
            
            for (const test of statisticsTests) {
                try {
                    await test.function();
                    testFramework.addResult(test.suite, test.name, true);
                    passed++;
                } catch (error) {
                    testFramework.addResult(test.suite, test.name, false, error);
                    failed++;
                }
            }
            
            testFramework.updateSummary(passed, failed);
        };

        // Auto-run tests on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                runAllTests();
            }, 500);
        });
    </script>
</body>
</html>